standard streams

streams can be modelled as processes of events:
stdout accepts sent strings and returns boolean based on the success of printing
stdin accepts sent strings and returns the input string
stderr accepts sent strings and returns null

---

extended type system

union types contain the set of values that conform to any of the types but only support operations shared by all of the types
intersection types contain the set of values that conform to all of the types but support operations of any of the types
member types specify the type of each of the elements in a sequence
for member types, <sequence> is equivalent to <sequence[untyped]>

extended types are written with angle bracket syntax:

union types
<list | string>
intersection types
<list & string>
member types
<list[string]>

extended type syntax is recursive:

<list[int | string] & record[int | string]>

when type checking, interfaces are equivalent to the union of the types that implement them
for example:

sequence is <string | list | record | slice>

---

aliasing

finally, a use for aliasing!
the user can define aliases for complex extended types:

user_type is <list[int & real] | record[int & real]>
user_type a: [1, 2, 3]

---

symbolic algebra

use the parse tree itself to represent expressions
nodes can signal to use symbolic representation if they produce a result that cannot be represented by numeric data types

---

single-line function/operator syntax

<name: callable> (<name>, ...) => <expression>

single-line type syntax

<name: type> [extends <name: type> [with <name: interface>, ...]] => <expression: boolean>

=> operator is equivalent to return statement

---

type checks for return and routine operators currently unimplemented
clean-up required for existing code base
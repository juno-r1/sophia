set-based type system

types are represented as sets
types are defined using set-builder notation
a type has a set of constraints that its members satisfy
a type check asserts the type's constraints for a value

for example:

type even extends int => even % 2 = 0
type a_string extends str => 'a' in a_string

types have subtype relations
a subtype has the constraints of all of its supertypes as well as its own
a value can be a member of any number of types

---

type operations

types are sets, and therefore support set operations

union types

union types represent the union of the specified types
union types support all of the values of the specified types

union types create a new type with these properties:
	the supertype is the mutual supertype of the specified types
	the constraints are the union of the specified types' constraints

union types are tagged; the tagged type is used in dispatch

for example:

type sequence: str
			 | list
			 | record
			 | slice

intersection types

intersection types represent the intersection of the specified types
intersection types support only the values in all of the specified types

intersection types create a new type with these properties:
	the supertype is the mutual supertype of the specified types
	the constraints are the intersection of the specified types' constraints

for example:

type pos_int: int & positive

member types

member types represent the type of the members of a compound type
member types create a new type with these properties:
	the supertype is the compound type
	the constraints are the constraints of the compound type

for example:

type list_of_int: list[int]

---

function composition

g.f(x) = g(f(x))

---

type checks for routine operators currently unimplemented
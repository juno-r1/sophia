to do

0.6.2

---

function composition is go
only problem is that i used the dot notation for it, which means that the type notation no longer works
consider some kind of solution using curly brackets?
e.g. list{str}{1}
i think this is the only nice way i have to notate these
i would be inclined to use angle brackets (e.g. list<str, 1>) but this introduces huge problems for parsing

---

are meta-statements really worth it?
consider eval/exec
eval has valid uses for namespace tricks, string manipulation, et cetera
exec is kind of dangerous and absolutely ruins the type system

make meta-statements occupy their own scope; cannot affect external scope except by messaging
compensate by adding apply
wow, sophia is surprisingly functional, huh?

---

change register allocation so that constants are assigned negative numbers / hash registers / figure out a way to give every register a unique hash

---

find a way to build sequences that doesn't suck

get the parser to detect the difference between a list and a record
hint: records always have : directly under the head node
instead of building a sequence and then converting it into a list or record -
create an empty list or record first and then concatenate to it

---

0.7

---

anonymous functions
(num x, num y) => x + y
the return type of an anonymous function must be inferred
this is going to do some terrible things to metis, isn't it

---

use statement
analogous to import statements or rust use statements
sophia needs a mechanism for extending namespaces regardless of how useful linking is

the use statement extends the current namespace with all top-level routine definitions in the target file
files targeted by the use statement are *not* executed, only compiled
code other than routine definitions is completely ignored

---

iteration over streams
the for statement just gets the next element from any given iterable
it stands to reason that this could work for infinite streams too

---

table type
implements a mutable collection of records with typed fields
take from sql, cobb's operators for table querying and manipulation

not using oop is all very well and good, but sophia lacks for useful complex data structures
custom tables should resolve this issue quite nicely
combined with the distributed functionalities of sophia, some powerful rdms capabilities are possible

tables should be "mutable" only in well-defined operations (insertion, deletion), like any other sequence
table operations and message passing should return copy, not reference
need to adhere to acid principles

---

extended static checker for sophia

type checking

this is a pretty much a solved problem for built-in types and operations
this is also a solved problem for user-defined operations, since those are required to specify their pre-conditions and post-conditions
when you introduce user-defined types, however, this becomes extremely non-trivial

this would be fine if you were able to, say, define all type relations in header files
however, types can and should be defined anywhere
these are the tradeoffs that a dynamic language must make
in a sufficiently dynamic language, such as this one, not all properties of the program can be statically known

so what can we know?

only the internal scope of any given procedure can be known
a procedure can and will be called in any environment
per the language specification, a procedure's types *do* need to be known when it is defined
this does not, guarantee, however, that they will be known in the calling scope
if the types aren't known in the calling scope, the checker should invalidate the call, since it is guaranteed to fail

the checker cannot know anything about a type that is outside the scope it was defined
nor can it know anything about types created, for example, in meta-statements
if the checker encounters the name of a type that is bound but not defined in scope, it must assume that the type exists but cannot assume anything about it

necessary to deal with conditional execution
keep track of scope through blocks, treating them as their own scopes
it should be possible to type check completely linearly, progressing through blocks as they come

what can the checker do?

the checker serves to verify the pre-conditions and post-conditions of every operation
when it does this, it is able to guarantee certain properties of arguments
to this end, the checker is also capable of detecting when a type check is unnecessary

the checker should therefore be able to edit and remove unnecessary type checks

---

constant folding and propagation

as a virtual register machine, sophia has to create every register it needs - and populate them with constants - at compile time
therefore, every constant is known at compile time
all built-ins are also available at compile time
this allows you to evaluate a wide range of expressions at compile time

constant folding does not involve block statements or function calls
this is not just running the program

the checker should remove unnecessary instructions after performing constant folding

every constant is unique (apart from null), which means there's no problem deleting or overwriting constant registers that aren't &0

---

pre-evaluated dispatch

if you're going to be type checking the whole program
and doing so basically requires performing dispatch on every instruction to verify that it works
and dispatch is deterministic for intraprocedural data
then you've basically already pre-evaluated dispatch

this allows us to partially build the instruction cache *at compile time*

---

metis

forget everything that was written here before
just write the simplest static analyser possible
no scopes, no conditional branching, no routine operators
just bind the damn addresses

the namespace framework has to operate differently here so as to preserve the registers for runtime
keep track of types, no values

aliasing can be performed at compile time simply by keeping a record of synonyms
there's no need to do anything to the data itself; just rewrite the instructions

---

binding implemented as normal

some internal instructions have a return type that must be inferred from the value (dependent type?)
this is a problem for metis, which does not have access to such a value
in these cases, what is the most consistent behaviour for metis?

metis should be conservative in its analysis
if a function's return type cannot be determined:
there should exist a signal that forces any further instruction reading from that return register to fail to cache

if at any point you don't know the return type of a function, how do you stop that from invalidating the rest of the program?
as it is, extremely common operations can cause the state of a whole program to become unknown

in practice, not so much
basically all data ends up either being bound, which always resolves the type, or being sent outside the routine
it's probably fine

---

operations that cause this state:

receive (n_rcv)
return type is determined by sending routine

resolve (u_rsv)
return type is determined by sending routine

binary safety operators (b_sfe)
return type is the type of the non-null operand

unsafety operator (u_usf)
return type is either the type of the operand or null

prototype constructor (u_new)
return type is the operand by definition

index for lists and records (.index)
return type is the member type of the sequence

iterator control (.next)
return type is the member type of the iterator or null

sequence constructor (.sequence)
return type is either list or record, but its operands fall outside of the type system

skip (.skip)
return type is the return type of the first function in the composition

cast (cast)
return type is the return type of the operand or null

reduce (reduce)
return type is the return type of the reducing function

consider rolling .next and .unloop into a single function
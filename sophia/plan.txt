to do

---

cache problem
caching only works for loops right now
caching *should* also work for function calls but the cache gets wiped every time a new method is defined

---

function composition is go
only problem is that i used the dot notation for it, which means that the type notation no longer works
consider some kind of solution using curly brackets?
e.g. list{str}{1}
i think this is the only nice way i have to notate these
i would be inclined to use angle brackets (e.g. list<str, 1>) but this introduces huge problems for parsing

---

input is bugged
multiprocessing shuts off stdin for all spawned processes
requires message to supervisor

known bug with dispatch tree generation
for example, t_slc and b_slc are distinguished by 0 supertype num instead of 2 supertype untyped
prioritise arity over supertype

---

extended static checker for sophia

type checking

this is a pretty much a solved problem for built-in types and operations
this is also a solved problem for user-defined operations, since those are required to specify their pre-conditions and post-conditions
when you introduce user-defined types, however, this becomes extremely non-trivial

this would be fine if you were able to, say, define all type relations in header files
however, types can and should be defined anywhere
these are the tradeoffs that a dynamic language must make
in a sufficiently dynamic language, such as this one, not all properties of the program can be statically known

so what can we know?

only the internal scope of any given procedure can be known
a procedure can and will be called in any environment
per the language specification, a procedure's types *do* need to be known when it is defined
this does not, guarantee, however, that they will be known in the calling scope
if the types aren't known in the calling scope, the checker should invalidate the call, since it is guaranteed to fail

the checker cannot know anything about a type that is outside the scope it was defined
nor can it know anything about types created, for example, in meta-statements
if the checker encounters the name of a type that is bound but not defined in scope, it must assume that the type exists but cannot assume anything about it

necessary to deal with conditional execution
keep track of scope through blocks, treating them as their own scopes
it should be possible to type check completely linearly, progressing through blocks as they come

what can the checker do?

the checker serves to verify the pre-conditions and post-conditions of every operation
when it does this, it is able to guarantee certain properties of arguments
to this end, the checker is also capable of detecting when a type check is unnecessary

the checker should therefore be able to edit and remove unnecessary type checks

---

constant folding and propagation

as a virtual register machine, sophia has to create every register it needs - and populate them with constants - at compile time
therefore, every constant is known at compile time
all built-ins are also available at compile time
this allows you to evaluate a wide range of expressions at compile time

constant folding does not involve block statements or function calls
this is not just running the program

the checker should remove unnecessary instructions after performing constant folding

---

pre-evaluated dispatch

if you're going to be type checking the whole program
and doing so basically requires performing dispatch on every instruction to verify that it works
and dispatch is deterministic for intraprocedural data
then you've basically already pre-evaluated dispatch

this allows us to partially build the instruction cache *at compile time*

---

name checking

because the analyser needs to retrieve the type information of every register for every instruction
it is possible to check that every register exists and is not reserved when invoked
this obviates the need to check for these errors at runtime

it also means that there's no need for dedicated bind instructions; these can be made into labels

in addition, some assertions can now be decided at compile time

CAUTION: this is strongly affected by the behaviour of meta-statements
in order for this to be able to work, meta-statements *must* occupy a different scope to where they are invoked

---

3/10(!) of all function calls and 7% of time are taken up by dispatch

to do:
fix the bug with dispatch
figure out how metis should work
change register allocation so that constants are assigned negative numbers / hash registers / figure out a way to give every register a unique hash

980215 function calls in 0.977 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.489    0.489    0.977    0.977 sophia.py:192(run)			    half of the runtime is spent purely inside run without calling anything else
    20004    0.045    0.000    0.062    0.000 arche.py:738(bind_untyped_type)	optimise out binds with metis
    70016    0.038    0.000    0.038    0.000 aletheia.py:86(describe)			occurs once per run cycle; find a way to get the needed type information closer to run
    20002    0.037    0.000    0.063    0.000 mathos.py:189(__add__)			rationals
   100023    0.034    0.000    0.034    0.000 aletheia.py:35(__gt__)			optimise out dispatch with metis; 1/10 of all function calls are supertype checking
    80017    0.032    0.000    0.032    0.000 aletheia.py:11(__init__)			---
    10002    0.032    0.000    0.044    0.000 mathos.py:267(__mod__)			rationals
    70016    0.031    0.000    0.031    0.000 aletheia.py:72(complete)			completing is better now; avoid inferring and also avoid calling this
    30004    0.029    0.000    0.035    0.000 mathos.py:42(__new__)			    rationals
    10001    0.024    0.000    0.033    0.000 arche.py:1115(unloop_untyped)		optimise out binds with metis
    80017    0.023    0.000    0.023    0.000 sophia.py:210(<listcomp>)			necessary
    10001    0.020    0.000    0.020    0.000 arche.py:961(loop_null)			necessary
    80017    0.020    0.000    0.020    0.000 sophia.py:217(<listcomp>)			necessary, despite appearances; many instructions need to know the signature
    60016    0.019    0.000    0.019    0.000 aletheia.py:119(supertype)		optimise out dispatch with metis
    30006    0.016    0.000    0.026    0.000 aletheia.py:68(merge)			    *please* find a different way to do this
    10001    0.011    0.000    0.061    0.000 arche.py:265(__new__)			    optimise out type checks with metis
    10002    0.010    0.000    0.041    0.000 mathos.py:445(__iter__)			rationals
    30006    0.010    0.000    0.010    0.000 {method 'update' of 'dict' objects}	see merge
    80017    0.010    0.000    0.010    0.000 aletheia.py:202(__bool__)			optimise out dispatch with metis
    70018    0.009    0.000    0.009    0.000 aletheia.py:115(__bool__)			optimise out dispatch with metis
    10001    0.006    0.000    0.042    0.000 arche.py:373(b_add)			    necessary
    30004    0.006    0.000    0.006    0.000 {built-in method __new__ of type object at 0x00007FF9225ECC60}	optimise out type checks with metis
    10002    0.006    0.000    0.051    0.000 arche.py:991(next_untyped)		necessary
    10002    0.005    0.000    0.005    0.000 mathos.py:383(__eq__)			    rationals
    10002    0.005    0.000    0.046    0.000 {built-in method builtins.next}	necessary
    10002    0.004    0.000    0.004    0.000 mathos.py:401(__le__)			    rationals
    20002    0.003    0.000    0.003    0.000 {built-in method math.gcd}		rationals
    10003    0.002    0.000    0.002    0.000 aletheia.py:260(subtype)			optimise out type checks with metis
        1    0.000    0.000    0.000    0.000 arche.py:1108(unloop_null)
        1    0.000    0.000    0.000    0.000 arche.py:943(iterator_slice)
        1    0.000    0.000    0.000    0.000 aletheia.py:234(infer_type)
        1    0.000    0.000    0.000    0.000 arche.py:573(t_slc)
        1    0.000    0.000    0.000    0.000 mathos.py:405(__ge__)
        1    0.000    0.000    0.000    0.000 sophia.py:247(branch)
        1    0.000    0.000    0.000    0.000 {built-in method builtins.iter}
        1    0.000    0.000    0.000    0.000 mathos.py:434(__init__)
        1    0.000    0.000    0.000    0.000 arche.py:1011(return_untyped)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}


         197 function calls in 1.228 seconds

---

inferral of member/length
oh my god

member and length should be inferred for sequences, but *not* for other values
therefore, either:
    enormous amounts of time are wasted inferring these values for non-sequences (current solution)
or:
    the interpreter has to know when it's returning a sequence
*or*:
    change the default values of descriptors so that non-sequences have member null and length 0
**or**
    create 2 virtual types, unit and sequence, that indicate this information
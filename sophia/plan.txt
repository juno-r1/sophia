standard streams

streams can be modelled as processes of events:
stdout accepts sent strings and returns boolean based on the success of printing
stdin accepts sent strings and returns the input string
stderr accepts sent strings and returns null

---

define type system as entity-relationship model

make process subtype of iterable / define iterator protocol for processes using resolution operator
above idea implements infinite streams, babey!
allow type checking to check for interfaces
code as specification
multiple dispatch?

---

extended type system

union types contain the set of values that conform to any of the types but only support operations shared by all of the types
intersection types contain the set of values that conform to all of the types but support operations of any of the types
member types specify the type of each of the elements in a sequence
for member types, <sequence> is equivalent to <sequence[untyped]>

extended types are written with angle bracket syntax:

union types
<list | string>
intersection types
<list & string>
member types
<list[string]>

extended type syntax is recursive:

<list[int | string] & record[int | string]>

when type checking, interfaces are equivalent to the union of the types that implement them
for example:

sequence is <string | list | record | slice>

---

aliasing

finally, a use for aliasing!
the user can define aliases for complex extended types:

user_type is <list[int & real] | record[int & real]>
user_type a: [1, 2, 3]

---

symbolic algebra

use the parse tree itself to represent expressions
nodes can signal to use symbolic representation if they produce a result that cannot be represented by numeric data types

---

single-line function/operator syntax

<name: callable> (<name>, ...) => <expression>

single-line type syntax

<name: type> [extends <name: type> [with <name: interface>, ...]] => <expression: boolean>

=> operator is equivalent to return statement

---

refactor runtime to instruction execution instead of tree traversal

allocate memory by creating list of registers using sethi-ullman algorithm
no need to worry about call stack or absolute jumps because calls spawn new tasks
only necessary to create registers per label
instructions allow null type but only if explicitly requested
e.g. assignment can get strings for names

model architecture as a RASP machine
instructions stored in register self.instructions
stack stored in register self.data
instruction counter stored in register self.path
sentinel value stored in register self.sentinel
all other registers constitute the namespace
optimise sethi-ullman algorithm by using names as addresses whenever possible
in fact, constants can be skipped as instructions completely by initialising registers *with constants already in them*

register 0 is the null address and the return value
if an instruction returns to register 0, assertion behaviour is assumed
instructions can also return to register 0 if the operation's return doesn't matter

; 0 .start
; 1 .start
.branch 0 &1
; 1 .branch
.bind a &2
; 2 null
.end 0
; 1 .end
; 1 .else
.bind a &3
; 2 null
.end 0
; 1 .end
.return 0 a
.return 0 &0
; 0 .end

.branch (conditional branch)

if condition is false:
branch to the next statement in the same or higher scope, past else statements

iterate through instructions until reaching an .end label
if the scope is equal to or less than the current scope,
and the next instruction is not an .else label:
continue execution from there

.else (unconditional branch)

branch to the next statement in the same or higher scope, including else statements

iterate through instructions until reaching an .end label
if the scope is equal to or less than the current scope:
continue execution from there
to do

0.6.2

---

function composition is go
only problem is that i used the dot notation for it, which means that the type notation no longer works
consider some kind of solution using curly brackets?
e.g. list{str}{1}
i think this is the only nice way i have to notate these
i would be inclined to use angle brackets (e.g. list<str, 1>) but this introduces huge problems for parsing

---

are meta-statements really worth it?
consider eval/exec
eval has valid uses for namespace tricks, string manipulation, et cetera
exec is kind of dangerous and absolutely ruins the type system

make meta-statements occupy their own scope; cannot affect external scope except by messaging
compensate by adding apply
wow, sophia is surprisingly functional, huh?

---

change register allocation so that constants are assigned negative numbers / hash registers / figure out a way to give every register a unique hash

---

0.7

---

anonymous functions
(num x, num y) => x + y
the return type of an anonymous function must be inferred
this is going to do some terrible things to metis, isn't it

---

use statement
analogous to import statements or rust use statement
sophia needs a mechanism for extending namespaces regardless of how useful linking is

the use statement extends the current namespace with all top-level routine definitions in the target file
files targeted by the use statement are *not* executed
code other than routine definitions is completely ignored

---

extended static checker for sophia

type checking

this is a pretty much a solved problem for built-in types and operations
this is also a solved problem for user-defined operations, since those are required to specify their pre-conditions and post-conditions
when you introduce user-defined types, however, this becomes extremely non-trivial

this would be fine if you were able to, say, define all type relations in header files
however, types can and should be defined anywhere
these are the tradeoffs that a dynamic language must make
in a sufficiently dynamic language, such as this one, not all properties of the program can be statically known

so what can we know?

only the internal scope of any given procedure can be known
a procedure can and will be called in any environment
per the language specification, a procedure's types *do* need to be known when it is defined
this does not, guarantee, however, that they will be known in the calling scope
if the types aren't known in the calling scope, the checker should invalidate the call, since it is guaranteed to fail

the checker cannot know anything about a type that is outside the scope it was defined
nor can it know anything about types created, for example, in meta-statements
if the checker encounters the name of a type that is bound but not defined in scope, it must assume that the type exists but cannot assume anything about it

necessary to deal with conditional execution
keep track of scope through blocks, treating them as their own scopes
it should be possible to type check completely linearly, progressing through blocks as they come

what can the checker do?

the checker serves to verify the pre-conditions and post-conditions of every operation
when it does this, it is able to guarantee certain properties of arguments
to this end, the checker is also capable of detecting when a type check is unnecessary

the checker should therefore be able to edit and remove unnecessary type checks

---

constant folding and propagation

as a virtual register machine, sophia has to create every register it needs - and populate them with constants - at compile time
therefore, every constant is known at compile time
all built-ins are also available at compile time
this allows you to evaluate a wide range of expressions at compile time

constant folding does not involve block statements or function calls
this is not just running the program

the checker should remove unnecessary instructions after performing constant folding

every constant is unique (apart from null), which means there's no problem deleting or overwriting constant registers that aren't &0

---

pre-evaluated dispatch

if you're going to be type checking the whole program
and doing so basically requires performing dispatch on every instruction to verify that it works
and dispatch is deterministic for intraprocedural data
then you've basically already pre-evaluated dispatch

this allows us to partially build the instruction cache *at compile time*

---

name checking

because the analyser needs to retrieve the type information of every register for every instruction
it is possible to check that every register exists and is not reserved when invoked
this obviates the need to check for these errors at runtime

it also means that there's no need for dedicated bind instructions; these can be made into labels

in addition, some assertions can now be decided at compile time

conditional control flow is no problem; we only care about what names are reserved
use union type checking for conditional branching; assume union type of all bindings

function scope presents a problem
sophia reserves all names in the calling scope (no shadowing) *but* allows referencing of names defined after the function definition
therefore, the only way to know what names are reserved are to evaluate at the scope of every call
keep a list of every register that a function writes to and compare against its calling scope

here's a fun hack: all final registers can be considered as "bound to"
therefore you can tell what names are being bound solely by looking at instruction registers

forget everything that was written here; shadowing is allowed now and only built-ins are reserved

because metis doesn't alter the initial namespace, the values dict provides all of the reserved names

every routine, including the main routine, should be represented by an object that stores:
- the registers that are referenced as arguments
- the registers that are bound to
- the functions that are called
fortunately, this is equivalent to, you know, the whole instruction
for every instruction, simply put all of its information into the current scope

...let's just go ahead and assume that loop variables persist after unlooping, too
just so we don't have to deal with temporary state
this way, only routines create new scope

unfortunately the namespace still *changes* so we can't do this all at the end
fortunately, you can only call functions that, you know, exist
which allows you to evaluate the namespace at the calling site
alternatively, attach the current namespace in the local scope to *every* instance of a call

what happens if, for some godforsaken reason, the user decides to shadow their own functions?
ooh babey it's time for another damn tree

what if, for some godforsaken reason, the user decides to *overwrite* their own functions?
well now i want to tear my face off
i am in hell!
guess we can just. you know. replicate the runtime environment. that works too. no halting problem in my language
with cut-off for recursive and mutually recursive functions, naturally
okay fuck it we're hashing functions based on their line number
that *has* to be unique
look. if you manage to define an infinite non-repeating series of functions then that's on you, really
this is precisely why sophia doesn't have a way to define functions as expressions - what about anonymous functions in meta-statements - shut the fuck up they don't break scope
there are no shortcuts. just do it

lol. lmao. name checking requires dispatch
type checking and name checking have to happen concurrently. fuck my stupid baka life, et cetera